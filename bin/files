#!/usr/bin/env bash

# exit on error
set -e

VERSION="files 0.1"

# source of all words: a wordlist
#
# define own wordlist with:
#    export WORDLIST=~/.my_own_private_wordlist
#
WORDLIST=${WORDLIST:-/usr/share/dict/words}


# terminal colors
GREEN="\033[0;32m"
GREY="\033[1;30m"
RESET="\033[0m"


# usage info
usage() {
  cat <<EOF

  Usage: files [options] [number-of-files/folders]

  Options:

    -f, --wordfile   Location of a wordfile
    -v, --version    Output version
    -h, --help       This message

  Examples:

    $ files
    $ files 10

EOF
}


#
# status message
#
# TODO pluralization
message() {
  if [ $number_of_folders -eq 0 ]; then
    echo -e "\n$GREY generated $GREEN$number_of_files files$GREY in current directory.$RESET"
  else
    echo -e "\n$GREY generated $GREEN$(( $number_of_files - $files_in_folder )) files$GREY in current directory and $GREEN$files_in_folder files$GREY in $GREEN$number_of_folders folders$GREY.$RESET"
  fi
}


#
# get array of N words from a wordlist $WORDLIST
#
words() {
  [ -z "$1" ] && echo "words() requires an argument" >&2 && exit 1

  local num=$1
  local w=()
  local list_length=$(cat $WORDLIST | wc -l)
  local MAX_RANDOM=32767   # http://wiki.bash-hackers.org/syntax/shellvars#random

  for (( i=0; i<num; i++ ))
  do
    local list_index=$(( $RANDOM * $list_length / $MAX_RANDOM + 1 ))
    local word=$(sed -n $(($list_index))p $WORDLIST | tr A-Z a-z)
    w[$i]=$word
  done
  echo "${w[@]}"
}


#
# make word sequence: word > word1 > word2 > ...
#
word_seq() {
  if [[ -f $1 || -d $1 ]]; then
    word_seq $(echo $1 | tr -d 0-9)$(( $(echo $1 | tr -d /a-z) + 1 ))
  else
    echo $1
  fi
}


# prevent the following statements from being sourced
[ $(basename $0) != "files" ] && exit 1


#
# parse command arguments
#
items=()
while test $# -ne 0; do
  arg=$1
  shift
  case $arg in
    -f|--wordfile)
      [ -z $1 ] && echo "provide a file" && echo 1
      [ ! -e $1 ] && echo "file doesn't exist" && echo 1
      WORDLIST=$1
      ;;
    -v|--version)
      echo $VERSION
      exit 1
      ;;
    -h|--help)
      usage
      exit 1
      ;;
    *)
      if [[ $arg =~ [[:digit:]] ]]; then
        items=(${items[@]} $arg)
      fi
      ;;
  esac
done


# number of generated files (defaults to a random number between 10 and 20 if number is not given)
number_of_files=${items[0]:-$(( $RANDOM % 20 + 10 ))}

# number of generated folders (defaults to a random number between 1 and 3 if number is not given)
number_of_folders=${items[1]:-$(( $RANDOM % 3 + 1 ))}

# number of files within a folder (defaults to half of files)
files_in_folder=${items[2]:-$(( $number_of_files / 2 ))}


# create folders and store folder names in array for later usage
folders=()
for word in $(words $number_of_folders)
do
  folder=$(word_seq $word)
  mkdir $folder
  folders=(${folders[@]} $folder)
done


# generate folders and files
i=0
for word in $(words $number_of_files)
do

  # create files in folders first ...
  if [ $i -lt $files_in_folder ] && [ $number_of_folders -gt 0 ]; then
    _word=$(word_seq ${folders[$(( $i % $number_of_folders ))]}/$word)
    echo $_word | sed 's/.*\///g' > $_word

  # ... and then files in current directory
  else
    _word=$(word_seq $word)
    echo $_word > $_word
  fi

  i=$(( $i + 1 ))
done

message
exit 0


# vim:ft=sh
