#!/usr/bin/env bash

# exit on error
set -e

VERSION="0.1"
FILES_SESSION="$PWD/.files"

# terminal colors
GREEN=$'\033[0;32m'
BLUE=$'\033[1;34m'
GREY=$'\033[1;30m'
RESET=$'\033[0m'


#
# print usage info
#
usage() {
  cat <<EOF
  random files generator
  version $VERSION

  Usage: ${0##*/} [options] [number-of-files/folders]

  Options:

    -f, --wordfile   Location of a wordfile
    -c, --content    Add Content to existing files
    -d, --delete     Delete generated files
    -s, --session    Start a new files session
    -l, --list       List generated files
    -v, --version    Output version
    -h, --help       This message

  Examples:

    $ files                              # generate a random number of files and folders
    $ files 10                           # generate 10 files
    $ files 10 2                         # generate 10 files and 2 folders
    $ files 10 2 6                       # generate 10 files of which 6 files are in 2 folders
    $ files -c                           # append content to all generated files
    $ files -3c                          # append 3 lines of content to all generated files
    $ files -f mywords.txt               # generate files & folders using words from mywords.txt
    $ cat mywords.txt | files            # generate files & folders using words from mywords.txt
    $ files <<< "foo"                    # generate files & folders using a single word "foo"
    $ echo -e "foo\nbar" | files 10      # generate files & folders using two words "foo" and "bar"

EOF
}


#
# status message
#
message() {
  if [ $number_of_folders -eq 0 ]; then
    echo -e "\n$GREY generated $GREEN$(unit $number_of_files file)$GREY in current directory.$RESET"
  else
    echo -e "\n$GREY generated $GREEN$(unit $(( $number_of_files - $files_in_folder )) file)$GREY in current directory and $GREEN$(unit $files_in_folder file)$GREY in $GREEN$(unit $number_of_folders folder)$GREY.$RESET"
  fi
}
unit() {
  local plural="s"
  [ $1 -eq 1 ] && plural=""
  echo "$1 $2$plural"
}


#
# get array of N words from a wordlist $WORDLIST
#
words() {
  local num=$1
  local w=()
  local list_length=$(wc -l < $WORDLIST)
  local MAX_RANDOM=32767   # http://wiki.bash-hackers.org/syntax/shellvars#random

  for (( i=0; i<num; i++ ))
  do
    local list_index=$(( $RANDOM * $list_length / $MAX_RANDOM + 1 ))
    local word=$(sanitize "$(sed -n $(($list_index))p $WORDLIST)")
    w[$i]=$word
  done
  echo "${w[@]}"
}


#
# create word sequence: word -> word1 -> word2 -> ...
#
word_seq() {
  if [[ -f $1 || -d $1 ]]; then
    word_seq $(seq $1)
  else
    echo $1
  fi
}


#
# sanitize words:
#   uppercase to lowercase
#   replace whitespaces and underscores with a dash
#   delete single quotes
#   delete numbers
#
sanitize() {
  echo $(echo $1 | tr A-Z a-z | tr -s ' _' '-' | tr -d "'")
}


#
# create next word: word<n> -> word<n+1>
#
seq() {
  echo $(echo $1 | tr -d 0-9)$(( $(echo $1 | tr -d /a-z-) + 1 ))
}


#
# get tempfile which stores a temporary wordlist
#
mktempfile() {
  echo $(mktemp -t ${1:-`basename $0`}XXXX)
}


#
# get session file which stores generated files
#
session() {
  [ ! -e $FILES_SESSION ] && touch $FILES_SESSION
  echo $FILES_SESSION
}


# source of all words: a wordlist
#
# define own wordlist with:
#    export WORDLIST=~/.my_wordlist
#
WORDLIST=${WORDLIST:-/usr/share/dict/words}
if [ -t 0 ]; then
  if [ ! -f $WORDLIST ]; then
    WORDLIST=$(mktempfile)
    for l in {a..z}; do echo $l >> $WORDLIST; done
  fi
else
  WORDLIST=$(mktempfile)
  while read stdin_line; do
    echo $stdin_line >> $WORDLIST
  done < "/dev/stdin"
fi

[ ! -s "$WORDLIST" ] && echo "${0##*/}: wordlist is empty" 1>&2 && exit 1


#
# parse command arguments
#
items=()
while test $# -ne 0; do
  arg=$1
  shift
  case $arg in
    -f|--wordfile)
      [ -z $1 ] && echo "provide a file" && echo 1
      [ ! -e $1 ] && echo "file doesn't exist" && echo 1
      WORDLIST=$1
      shift
      ;;
    -c|--content)
      for f in `cat $FILES_SESSION`
      do
        [ -f $f ] && echo $(seq `tail -n 1 $f`) >> $f
      done
      exit 1
      ;;
    -*c)
      n=$(echo $arg | tr -cd '[[:digit:]]')
      for f in `cat $FILES_SESSION`
      do
        [ -f $f ] && for (( i=0; i<n; i++ )); do echo $(seq `tail -n 1 $f`) >> $f; done
      done
      exit 1
      ;;
    -d|--delete)
      # delete files first, then folders. As folders were written first, we delete entries in reverse order
      tail -r $FILES_SESSION | xargs rm -r
      rm $FILES_SESSION
      exit 1
      ;;
    -s|--session)
      rm $FILES_SESSION
      exit 1
      ;;
    -l|--list)
      for f in `cat $FILES_SESSION | sort`
      do
        [ -d $f ] && echo "$BLUE${f}/$RESET" || { echo $f | sed "s/^\(.*\)\//$BLUE\1\/$RESET/"; }
      done
      exit 1
      ;;
    -v|--version)
      echo $VERSION
      exit 1
      ;;
    -h|--help)
      usage
      exit 1
      ;;
    *)
      if [[ $arg =~ [[:digit:]] ]]; then
        items=(${items[@]} $arg)
      else
        echo $arg
      fi
      ;;
  esac
done


# number of generated files (defaults to a random number between 10 and 20 if not given)
number_of_files=${items[0]:-$(( $RANDOM % 20 + 10 ))}

# if only numer_of_files is given, intentionally set number_of_folders to zero
[ ${#items[@]} == 1 ] && items[1]=0

# number of generated folders (defaults to a random number between 1 and 3 if number is not given)
number_of_folders=${items[1]:-$(( $RANDOM % 3 + 1 ))}

# number of files within a folder (defaults to half of files)
files_in_folder=${items[2]:-$(( $number_of_files / 2 ))}


#
# create folders and store folder names in array for later usage
#
folders=()
for word in $(words $number_of_folders)
do
  folder=$(word_seq $word)
  mkdir $folder
  echo $folder >> $(session)
  folders=(${folders[@]} $folder)
done


#
# generate folders and files
#
i=0 # loop-index
for word in $(words $number_of_files)
do

  # create files in folders first ...
  if [ $i -lt $files_in_folder ] && [ $number_of_folders -gt 0 ]; then
    _word=$(word_seq ${folders[$(( $i % $number_of_folders ))]}/$word)
    echo $_word | sed 's/.*\///g' > $_word
    echo $_word >> $(session)

  # ... and then files in current directory
  else
    _word=$(word_seq $word)
    echo $_word > $_word
    echo $_word >> $(session)
  fi

  i=$(( $i + 1 ))
done

message
exit 0


# vim:ft=sh
