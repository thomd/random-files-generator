#!/usr/bin/env bash

# exit on error
set -e

VERSION="0.1"

# source of all words: a wordlist
#
# define own wordlist with:
#    export WORDLIST=~/.my_own_private_wordlist
#
WORDLIST=${WORDLIST:-/usr/share/dict/words}
if [ -t 0 ]; then
  if [ ! -f $WORDLIST ]; then
    WORDLIST=$(mktemp -t `basename $0`XXXX)
    for l in {a..z}; do echo $l >> $WORDLIST; done
  fi
else
  WORDLIST=$(mktemp -t `basename $0`XXXX)
  while read stdin_line; do
    echo $stdin_line >> $WORDLIST
  done < "/dev/stdin"
fi

[ ! -s "$WORDLIST" ] && echo "${0##*/}: wordlist is empty" 1>&2 && exit 1


# terminal colors
GREEN="\033[0;32m"
GREY="\033[1;30m"
RESET="\033[0m"


# usage info
usage() {
  cat <<EOF

  Usage: ${0##*/} [options] [number-of-files/folders]

  Options:

    -f, --wordfile   Location of a wordfile
    -c, --content    Add Content to existing files
    -v, --version    Output version
    -h, --help       This message

  Examples:

    $ files                              # generate a random number of files and folders
    $ files 10                           # generate 10 files, some of them in folders
    $ files 10 0                         # generate 10 files only
    $ files 10 2 6                       # generate 10 files of which 6 files are in 2 folders
    $ files -c                           # append furher content to all files in CWD
    $ files -f mywords.txt               # generate files & folders using words from mywords.txt
    $ cat mywords.txt | files            # generate files & folders using words from mywords.txt
    $ files <<< "foo"                    # generate files & folders using a single word "foo"
    $ echo -e "foo\nbar" | files 10      # generate files & folders using two words "foo" and "bar"

EOF
}


#
# status message
#
message() {
  if [ $number_of_folders -eq 0 ]; then
    echo -e "\n$GREY generated $GREEN$(unit $number_of_files file)$GREY in current directory.$RESET"
  else
    echo -e "\n$GREY generated $GREEN$(unit $(( $number_of_files - $files_in_folder )) file)$GREY in current directory and $GREEN$(unit $files_in_folder file)$GREY in $GREEN$(unit $number_of_folders folder)$GREY.$RESET"
  fi
}
unit() {
  local plural="s"
  [ $1 -eq 1 ] && plural=""
  echo "$1 $2$plural"
}


#
# get array of N words from a wordlist $WORDLIST
#
words() {
  local num=$1
  local w=()
  local list_length=$(wc -l < $WORDLIST)
  local MAX_RANDOM=32767   # http://wiki.bash-hackers.org/syntax/shellvars#random

  for (( i=0; i<num; i++ ))
  do
    local list_index=$(( $RANDOM * $list_length / $MAX_RANDOM + 1 ))
    local word=$(sed -n $(($list_index))p $WORDLIST | tr A-Z a-z | tr -s ' ' '-' | tr -d "'")
    w[$i]=$word
  done
  echo "${w[@]}"
}


#
# create word sequence: word -> word1 -> word2 -> ...
#
word_seq() {
  if [[ -f $1 || -d $1 ]]; then
    word_seq $(seq $1)
  else
    echo $1
  fi
}


#
# create next word: word<n> -> word<n+1>
#
seq() {
  echo $(echo $1 | tr -d 0-9)$(( $(echo $1 | tr -d /a-z-) + 1 ))
}


#
# parse command arguments
#
items=()
while test $# -ne 0; do
  arg=$1
  shift
  case $arg in
    -f|--wordfile)
      [ -z $1 ] && echo "provide a file" && echo 1
      [ ! -e $1 ] && echo "file doesn't exist" && echo 1
      WORDLIST=$1
      ;;
    -c|--content)
      for f in `find . -type f -not -path "*.git*" -not -path "*.svn*"`
      do
         echo $(seq `tail -n 1 $f`) >> $f
      done
      exit 1
      ;;
    -v|--version)
      echo $VERSION
      exit 1
      ;;
    -h|--help)
      usage
      exit 1
      ;;
    *)
      if [[ $arg =~ [[:digit:]] ]]; then
        items=(${items[@]} $arg)
      fi
      ;;
  esac
done


# number of generated files (defaults to a random number between 10 and 20 if number is not given)
number_of_files=${items[0]:-$(( $RANDOM % 20 + 10 ))}

# number of generated folders (defaults to a random number between 1 and 3 if number is not given)
number_of_folders=${items[1]:-$(( $RANDOM % 3 + 1 ))}

# number of files within a folder (defaults to half of files)
files_in_folder=${items[2]:-$(( $number_of_files / 2 ))}


# create folders and store folder names in array for later usage
folders=()
for word in $(words $number_of_folders)
do
  folder=$(word_seq $word)
  mkdir $folder
  folders=(${folders[@]} $folder)
done


# generate folders and files
i=0
for word in $(words $number_of_files)
do

  # create files in folders first ...
  if [ $i -lt $files_in_folder ] && [ $number_of_folders -gt 0 ]; then
    _word=$(word_seq ${folders[$(( $i % $number_of_folders ))]}/$word)
    echo $_word | sed 's/.*\///g' > $_word

  # ... and then files in current directory
  else
    _word=$(word_seq $word)
    echo $_word > $_word
  fi

  i=$(( $i + 1 ))
done

message
exit 0


# vim:ft=sh
